name: Go Build and Test API

on:
  push:
    branches: ["main"] # Or your default branch
    paths:
      - "cmd/api/v1/**" # Only run if files in this path change
      - "go.mod"
      - "go.sum"
      - ".github/workflows/**"
  pull_request:
    branches: ["main"] # Or your default branch
    paths:
      - "cmd/api/v1/**"
      - "go.mod"
      - "go.sum"
      - ".github/workflows/**"

jobs:
  test: # Separate job for testing, runs once
    runs-on: ubuntu-latest
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: "1.24" # Specify your Go version

      - name: Run tests
        run: go test -v ./cmd/api/v1/...

  build:
    needs: test # Ensure tests pass before building
    runs-on: ubuntu-latest # Can still use ubuntu for cross-compilation
    strategy:
      matrix:
        goos: [linux, windows, darwin] # Target Operating Systems
        goarch: [amd64] # Target Architectures (can add arm64, etc.)
        # You can add specific combinations or exclude some if needed:
        # include:
        #   - goos: linux
        #     goarch: arm64
        # exclude:
        #   - goos: darwin
        #     goarch: 386 # if you don't want to build for 32-bit macOS

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version: "1.24" # Specify your Go version

      - name: Build API executable for ${{ matrix.goos }}/${{ matrix.goarch }}
        env:
          GOOS: ${{ matrix.goos }}
          GOARCH: ${{ matrix.goarch }}
        run: |
          output_name="myapi_executable"
          if [ "$GOOS" = "windows" ]; then
            output_name="${output_name}.exe"
          fi
          echo "Building for $GOOS/$GOARCH, output: $output_name"
          go build -v -o "$output_name" ./cmd/api/v1

      - name: Upload API executable artifact
        uses: actions/upload-artifact@v4
        with:
          name: api-v1-executable-${{ matrix.goos }}-${{ matrix.goarch }}
          path: |
            myapi_executable
            myapi_executable.exe
          if-no-files-found: error
          # The path will try to upload both, but only one will exist per job run.
          # This is a simple way to handle the .exe extension for Windows.
          # Alternatively, you can make the path conditional or use the output_name from the build step.
